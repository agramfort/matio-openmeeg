SET(PACKAGE_VERSION_MAJOR "1")
SET(PACKAGE_VERSION_MINOR "3")
SET(PACKAGE_VERSION_PATCH "4")

SET(CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake;${CMAKE_CURRENT_SOURCE_DIR}/cmake/FortranCInterface")

# ===========
# = Options =
# ===========

OPTION(ENABLE_FORTRAN "Enable fortran interface to mat library")
SET(EXTRA_LANGAGE)
IF (ENABLE_FORTRAN)
    SET(EXTRA_LANGAGE Fortran)
    SET(MATIO_FORTRAN TRUE)
ENDIF()

PROJECT(MATIO C ${EXTRA_LANGAGE})

SET(MATIO_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})
SET(MATIO_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR})

CMAKE_MINIMUM_REQUIRED(VERSION 2.6.4)

SET(MATIO_PLATFORM ${CMAKE_SYSTEM_PROCESSOR}--${CMAKE_SYSTEM_NAME})

INCLUDE(FindLibrary)

# =======================
# = HANDLE DEFINITTIONS =
# =======================

INCLUDE(Boolean)
BOOLEAN(LINUX UNIX AND NOT APPLE)
BOOLEAN(WINNT WIN32)
BOOLEAN(SUN XXXX)

# ===========
# = Options =
# ===========

INCLUDE(DefaultFileVersion)

OPTION(ENABLE_PROFILE "Turn on profile")
IF (ENABLE_PROFILE)
ENDIF()

OPTION(EXTENDED_SP "Enable extended sparse matrix data types not supported in Matlab" ON)
IF (EXTENDED_SP)
    SET(EXTENDED_SPARSE 1)
ENDIF()

INCLUDE (Documentation OPTIONAL)
IF (BUILD_DOCUMENTATION)
    ADD_SUBDIRECTORY(doxygen)
ENDIF()

# =================
# = Check headers =
# =================

# Provide stdint.h for windows.

IF (WIN32 AND NOT CYGWIN_INSTALL_PATH)
    SET(CMAKE_REQUIRED_INCLUDES ${CMAKE_CURRENT_SOURCE_DIR}/contrib/Windows)
    INCLUDE_DIRECTORIES(contrib/Windows)
ENDIF()

INCLUDE(CheckIncludeFile)
INCLUDE(CheckHeaderSTDC)

CHECK_INCLUDE_FILE(inttypes.h HAVE_INTTYPES_H)
CHECK_INCLUDE_FILE(stdint.h   HAVE_STDINT_H)
CHECK_INCLUDE_FILE(strings.h  HAVE_STRINGS_H)
CHECK_INCLUDE_FILE(ctype.h    HAVE_CTYPE_H)
CHECK_INCLUDE_FILE(string.h   HAVE_STRING_H)
CHECK_INCLUDE_FILE(malloc.h   HAVE_MALLOC_H)
CHECK_HEADER_STDC()

# ===================
# = Check type size =
# ===================

INCLUDE(CheckTypeSize)
SET(TYPES double float long int short char)
FOREACH(TYPE ${TYPES})
    string(TOUPPER ${TYPE} TYPE_UPPER)
    CHECK_TYPE_SIZE(${TYPE} SIZEOF_${TYPE_UPPER})
    SET(HAVE_${TYPE_UPPER} 1)
ENDFOREACH()
CHECK_TYPE_SIZE(void* SIZEOF_VOID_PTR)

SET(TYPES uint8_t uint16_t uint32_t uint64_t int8_t int16_t int32_t int64_t)
FOREACH(TYPE ${TYPES})
    string(TOUPPER ${TYPE} TYPE_UPPER)
    CHECK_TYPE_SIZE(${TYPE} SIZEOF_${TYPE_UPPER})
    SET(HAVE_MAT_${TYPE_UPPER} 1)
    IF(NOT "${SIZEOF_${TYPE_UPPER}}")
        MESSAGE(FATAL_ERROR "Unknown type ${TYPE}")
    ENDIF()
ENDFOREACH()

# ===================
# = Check functions =
# ===================

INCLUDE(CheckFunctionExists)
CHECK_FUNCTION_EXISTS(vsnprintf HAVE_VSNPRINTF)
CHECK_FUNCTION_EXISTS(snprintf  HAVE_SNPRINTF)
CHECK_FUNCTION_EXISTS(vasprintf HAVE_VASPRINTF)
CHECK_FUNCTION_EXISTS(asprintf  HAVE_ASPRINTF)

INCLUDE(VA_COPY)
VA_COPY()

IF (WIN32)
    SET(LIBRARY_OUTPUT_PATH    "${CMAKE_BINARY_DIR}")
    SET(EXECUTABLE_OUTPUT_PATH "${CMAKE_BINARY_DIR}")
ENDIF()

# =========
# = Z Lib =
# =========

OPTION(USE_SYSTEM_ZLIB "Use installed zlib if possible" ON)
MARK_AS_ADVANCED(USE_SYSTEM_ZLIB)

STRING(COMPARE NOTEQUAL "${USE_SYSTEM_ZLIB_STATUS}" "" USE_SYSTEM_ZLIB_STATUS_NOT_EMPTY)
IF(USE_SYSTEM_ZLIB_STATUS_NOT_EMPTY)
    STRING(COMPARE NOTEQUAL "${USE_SYSTEM_ZLIB_STATUS}" "${USE_SYSTEM_ZLIB}" RESET)
ENDIF()

# Store in cache previous value of BUILD_SHARED
SET(USE_SYSTEM_ZLIB_STATUS "${USE_SYSTEM_ZLIB}" CACHE INTERNAL "Previous system zlib status" FORCE)

IF (${RESET})
    UNSET(SYSTEM_ZLIB)
    UNSET(SYSTEM_ZLIB CACHE)
    UNSET(Z_LIBRARY)
    UNSET(Z_LIBRARY CACHE)
ENDIF()

IF (USE_SYSTEM_ZLIB)
    FIND_LIBRARY(SYSTEM_ZLIB z)
    IF (SYSTEM_ZLIB)
        SET(Z_LIBRARY ${SYSTEM_ZLIB} CACHE STRING "TEST")
    ELSE()
        SET(USE_LOCAL_ZLIB 1)
    ENDIF()
ENDIF()

IF (NOT USE_SYSTEM_ZLIB OR USE_LOCAL_ZLIB)
    ADD_SUBDIRECTORY(zlib)
    INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/zlib ${CMAKE_CURRENT_BINARY_DIR}/zlib)
    IF (NOT BUILD_SHARED)
        SET(TARGET_SUFFIX -static)
    ENDIF()
    SET(Z_LIBRARY zlib)
ENDIF()

SET(HAVE_ZLIB 1)
SET(Z_PREFIX)

INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR}/src)
INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/src)
ADD_SUBDIRECTORY(src)

# ==============
# = pkg-config =
# ==============

SET(prefix ${CMAKE_INSTALL_PREFIX})
SET(VERSION ${PACKAGE_VERSION_MAJOR}.${PACKAGE_VERSION_MINOR}.${PACKAGE_VERSION_PATCH})
SET(exec_prefix "\${prefix}")
SET(libdir "\${exec_prefix}/lib")
SET(includedir "\${prefix}/include")
SET(ZLIB_LIBS ${Z_LIBRARY})

CONFIGURE_FILE(
    "${CMAKE_CURRENT_SOURCE_DIR}/matio.pc.in"
    "${CMAKE_CURRENT_BINARY_DIR}/matio.pc"
    IMMEDIATE @ONLY)

# ===========
# = Testing =
# ===========
OPTION(BUILD_TESTING "Build tests" ON)
IF (BUILD_TESTING)
    INCLUDE(CTest)
    ENABLE_TESTING()
    ADD_SUBDIRECTORY(test)
ENDIF()

# =============
# = Uninstall =
# =============
CONFIGURE_FILE(
    "${CMAKE_CURRENT_SOURCE_DIR}/cmake_uninstall.cmake.in"
    "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
    IMMEDIATE @ONLY)

ADD_CUSTOM_TARGET(uninstall
    "${CMAKE_COMMAND}" -P "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake")

#-----------------------------------------------
# packaging
#-----------------------------------------------

INCLUDE(Packaging)
